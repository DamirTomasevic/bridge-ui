\section{ZK-EVM Circuits}

The ZK-EVM circuits is the core subsystem which allows Taiko to prove an Ethereum-equivalent chain in sub-linear time. This key property allows Taiko to be a scalability solution for Ethereum without additional security assumptions, except that the cryptography and code used in the implementation is secure.

\subsection{Proof Generation} The proof computation function $\hat{C}$ for address $a$ is defined as:

\begin{eqnarray}
    p^z(a) \equiv \hat{C}(a, H,\theta, L, \Delta(\theta::V^t(L)),\kappa_z )
\end{eqnarray}
Where $H$ is the block header, $\theta$ is the anchor transaction, $L$ is the block's RLP-encoded txList, $\Delta$ is the EVM trace logs generated from running $\theta$ and all transactions in $L$ that the \textit{Contextual Validity} $V^t$ function returns \texttt{True}, and $\kappa_z$ is  ZK-EVM's proving key.

We assume:
\begin{enumerate}
\item The ZK-EVM always generates a different proof if an input is changed.
\item The ZK-EVM is unable to generate a proof if the txList fails to pass the Block Intrinsic Validity test or any transaction (including the anchor transaction) fails to pass the transaction Contextual Validity test.
\item The ZK-EVM disables the same set of Ethereum upgrades listed in Appendix \ref{sec:eips}
\end{enumerate}

By making the prover address $a$ an input we can ensure a proof is directly linked to a specific address. This prevents proofs from being stolen while their enclosing transactions are pending in Ethereum's mempool as changing the address requires regenerating the complete proof.

\subsection{Proof Verification} To verify a validity proof $p^z$ generated by address $a$ for the $i$-th block, we have the verification function defined as:

\begin{eqnarray}
    \hat{V}(p^z, a, h[i], \texttt{KEC}(L), \kappa_v)
\end{eqnarray}
Where $h[i]$ is the block's block hash, $\kappa_v$ is ZK-EVM's verification key.
